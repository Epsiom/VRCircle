using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// The component in charge of the behaviour of one single enemy in a flock, generated by FlockManagerBehaviour
public class FlockEnemyBehaviour : MonoBehaviour
{
    public float speed = 2f;              // Speed of the boid
    public float neighborRadius = 0.1f;   // Radius to detect neighbors
    public float separationWeight = 1.5f; // Weight for separation force
    public float alignmentWeight = 1f;    // Weight for alignment force
    public float cohesionWeight = 1f;     // Weight for cohesion force
    public float boundaryRadius = 2f;   // Half the diameter (0.5 units radius for 1 unit diameter)

    private Vector3 velocity;

    void Start()
    {
        velocity = Random.insideUnitSphere.normalized * speed;  // Random initial velocity
    }

    void Update()
    {
        // Gets nearby boids within the detection radius
        Collider[] nearbyBoids = Physics.OverlapSphere(transform.position, neighborRadius);

        Vector3 separation = Vector3.zero;
        Vector3 alignment = Vector3.zero;
        Vector3 cohesion = Vector3.zero;

        int neighborCount = 0;

        foreach (Collider boid in nearbyBoids)
        {
            if (boid != this.GetComponent<Collider>()) // Exclude self
            {
                Vector3 toNeighbor = transform.localPosition - boid.transform.localPosition;
                separation += toNeighbor.normalized / toNeighbor.magnitude;  // Separation force (inverse of distance)
                alignment += boid.GetComponent<Rigidbody>().velocity;       // Alignment force
                cohesion += boid.transform.localPosition;                        // Cohesion force
                neighborCount++;
            }
        }

        if (neighborCount > 0)
        {
            // Averages all forces
            separation /= neighborCount;
            alignment /= neighborCount;
            cohesion /= neighborCount;

            cohesion = (cohesion - transform.localPosition).normalized; // Direction towards the average position
        }

        // Calculates the final velocity based on weighted forces
        Vector3 finalVelocity = velocity.normalized
            + separation * separationWeight
            + alignment.normalized * alignmentWeight
            + cohesion * cohesionWeight;

        // Constrains the velocity
        velocity = finalVelocity.normalized * speed;

        // Boundary condition (spherical constraint)
        if (transform.localPosition.magnitude > boundaryRadius)
        {
            Vector3 toCenter = -transform.localPosition.normalized;
            velocity += toCenter * speed; // Push back toward center of the sphere
        }

        // Updates the position based on velocity
        transform.localPosition += velocity * Time.deltaTime;
        transform.LookAt(transform.position + velocity);
    }
}


/*public class FlockEnemyBehaviour : MonoBehaviour
{
    // https://youtu.be/6dJlhv3hfQ0?si=qRCOU9PvKl0IuXeM

    private List<FlockEnemyBehaviour> _boidList;
    private FlockManagerBehaviour _flockManagerBehaviour;
    private Rigidbody _rigidbody;

    private const float SPEED = 1f;
    private const float FIELD_OF_VIEW_ANGLE = 90f;
    private const float FIELD_OF_VIEW_DISTANCE = 1f;
    private const float SEPARATION_RADIUS = 0.2f;
    private const float BOUNDARY_RADIUS = 2f;

    private void Start()
    {
        _rigidbody = GetComponent<Rigidbody>();
    }

    void Update()
    {
        List<FlockEnemyBehaviour> boidsInFOV = GetBoidsInFieldOfView();
        Vector3 separation = ComputeSeparationVector(boidsInFOV);
        Vector3 alignment = ComputeAlignmentVector(boidsInFOV);
        Vector3 cohesion = ComputeCohesionVector(boidsInFOV);
        Vector3 boundaryKeeping = (transform.localPosition.magnitude > BOUNDARY_RADIUS) ? -transform.position.normalized * SPEED : Vector3.zero;

        _rigidbody.velocity = (transform.forward + separation + alignment + cohesion + boundaryKeeping).normalized * SPEED;
    }

    public void Init(FlockManagerBehaviour flockManagerBehaviour, List<FlockEnemyBehaviour> boidList)
    {
        _flockManagerBehaviour = flockManagerBehaviour;
        _boidList = boidList;
    }

    Vector3 ComputeSeparationVector(List<FlockEnemyBehaviour> boidsInFOV)
    {
        Vector3 direction = Vector3.zero;
        foreach(FlockEnemyBehaviour boid in boidsInFOV)
        {
            float ratio = Mathf.Clamp01((boid.transform.position - transform.position).magnitude / SEPARATION_RADIUS);
            direction -= ratio * (boid.transform.position - transform.position);
        }

        return direction.normalized;
    }

    Vector3 ComputeAlignmentVector(List<FlockEnemyBehaviour> boidsInFOV)
    {
        Vector3 direction = Vector3.zero;
        foreach (FlockEnemyBehaviour boid in boidsInFOV)
        {
            float ratio = Mathf.Clamp01((boid.transform.position - transform.position).magnitude / SEPARATION_RADIUS);
            direction -= ratio * boid.transform.forward;
        }
        return direction.normalized;
    }

    Vector3 ComputeCohesionVector(List<FlockEnemyBehaviour> boidsInFOV)
    {
        Vector3 averageBoidPosition = Vector3.zero;
        foreach (FlockEnemyBehaviour boid in boidsInFOV)
        {
            averageBoidPosition -= boid.transform.position;
        }
        averageBoidPosition = averageBoidPosition / boidsInFOV.Count;
        return (averageBoidPosition - this.transform.position).normalized;
    }

    List<FlockEnemyBehaviour> GetBoidsInFieldOfView()
    {
        return _boidList.FindAll(b => b != this
            && (b.transform.position - transform.position).magnitude <= FIELD_OF_VIEW_DISTANCE
            && Vector3.Dot(transform.forward, (b.transform.position - transform.position)) > FIELD_OF_VIEW_ANGLE);
    }
}
*/